'''Проанализировать скорость и сложность одного любого алгоритма
из разработанных в рамках домашнего задания первых трех уроков.

Примечание. Идеальным решением будет:

a. выбрать хорошую задачу, которую имеет смысл оценивать,

b. написать 3 варианта кода (один у вас уже есть),

c. проанализировать 3 варианта и выбрать оптимальный,

d. результаты анализа вставить в виде комментариев в файл с кодом
(не забудьте указать, для каких N вы проводили замеры),

e. написать общий вывод: какой из трёх вариантов лучше и почему.'''


'''Использую задачу с переворотом числа, так как есть несколько решений с использованием
чисел и строк'''

from random import randint
import timeit
import cProfile

def num(n):
    '''Функция придумывания большого числа, вывод в форме строки'''

    res = ''
    for i in range(n):
        res += str(randint(0, 9))

    return res

'''Результаты по длительности придумывания самого числа
    (чтобы потом сравнить с длительностью его поворота, в длительности работы учавствует генератор)'''

#cProfile.run('num(10**3)')
#1   0.001   0.001   0.004   0.004   task01.py: 25(num)

#cProfile.run('num(10**4)')
#1   0.009   0.009  0.032  0.032   task01.py: 25(num)

#cProfile.run('num(10**5)')
#1    0.086    0.086    0.291    0.291 task01.py:25(num)

'''В последующем: длительность самого выполнения кода удлиняется за счет генерации числа
(в основном работа модулей randrange и randint, если посмотреть отчет cProfile),
поэтому числа больше 10**6 знаков не брал - подвисать начинает'''

'''Создаем разной длины числа'''
a = num(10**3)
#a = num(10**4)
#a = num(10**5)


def revers_1(n):
    '''Поворот числа через арифметические действия'''

    n = int(n)
    rev = ''
    while True:
        rev += str(n % 10)
        n //= 10
        if n == 0:
            break
    return rev

#cProfile.run('revers_1(a)')
#1   0.002   0.002   0.002   0.002   task01.py: 50(revers_1)    с числом символов 10**3
#1   0.156   0.156   0.156   0.156   task01.py: 50(revers_1)    с числом символов 10**4
#1   14.401   14.401   14.401   14.401 task01.py:50(revers_1)   с числом символов 10**5

'''Поворот числа идет довольно длительно за счет выполнения арифметических
действий в объеме равное количеству знаков * 2. Рост нелинеен (как раз 10**2).
+ Каждый раз запись нового результата при выполнении цикла'''

def revers_2(n):
    'Поворот числа через создание новой строки и заполнения последней по 1 элементу'

    res = ''
    for i in n:
        res += i
    return res

#cProfile.run('revers_2(a)')
#1    0.000    0.000    0.000    0.000 task01.py:75(revers_2)   с числом символов 10**3
#1    0.001    0.001    0.001    0.001 task01.py:75(revers_2)   с числом символов 10**4
#1    0.011    0.011    0.011    0.011 task01.py:75(revers_2)   с числом символов 10**5

'''По сути простой перебор каждого символа, что значительно ускоряет работу, здесь уже виден
    линейный рост'''

def revers_3(n):
    '''Поворот числа-строки через встоенный алгоритм'''

    return n[::-1]

#cProfile.run('revers_3(a)')
#1    0.000    0.000    0.000    0.000 task01.py:92(revers_3)   с числом символов 10**3
#1    0.000    0.000    0.000    0.000 task01.py:92(revers_3)   с числом символов 10**4
#1    0.000    0.000    0.000    0.000 task01.py:92(revers_3)   с числом символов 10**5

'''Я на самом деле ожидал, что результат будет схож с перебором каждого символа, 
но в этом случае не тратится время на запись каждый раз нового значения при выполнении цикла
из revers_2. Вывод очевиден'''

#timeit.timeit('revers_1(a)')

